---
title: 'Assignment 10: Predictive Modeling & Geospatial Risk Models - Predicting Assault in Chicago'
author: "Sara Mattio"
date: "11/8/2019"
output:
  html_document:
    theme: united
    toc: true
    toc_float: true
    code_folding: hide
---

```{r setup, include=FALSE}
library(tidyverse)
library(sf)
library(QuantPsyc)
library(RSocrata)
library(viridis)
library(caret)
library(spatstat)
library(spdep)
library(FNN)
library(grid)
library(gridExtra)
library(knitr)
library(kableExtra)
library(tidycensus)
census_api_key("bb77f2a147934164e965121bd02b5cc9e22f3165", overwrite = TRUE, install = TRUE)

mapTheme <- function(base_size = 12) {
  theme(
    text = element_text( color = "black"),
    plot.title = element_text(size = 14,colour = "black"),
    plot.subtitle=element_text(face="italic"),
    plot.caption=element_text(hjust=0),
    axis.ticks = element_blank(),
    panel.background = element_blank(),axis.title = element_blank(),
    axis.text = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_rect(colour = "black", fill=NA, size=2)
  )
}

#police districts and beats
policeDistricts <- 
  st_read("https://data.cityofchicago.org/api/geospatial/fthy-xz3r?method=export&format=GeoJSON") %>%
  st_transform(crs=102271) %>%
  dplyr::select(District = dist_num)

policeBeats <- 
  st_read("https://data.cityofchicago.org/api/geospatial/aerh-rz74?method=export&format=GeoJSON") %>%
  st_transform(crs=102271) %>%
  dplyr::select(District = beat_num)

bothPoliceUnits <- rbind(mutate(policeDistricts, Legend = "Police Districts"), 
                         mutate(policeBeats, Legend = "Police Beats"))

#bring in Chicago map and create fishnet
chicagoBoundary <- 
  st_read("C:/Users/ssmat/Desktop/MUSA507/Week10/riskPrediction_data/chicagoBoundary.shp") %>%
  st_transform(crs=102271)
fishnet <- 
  st_make_grid(chicagoBoundary, cellsize = 500) %>%
  st_sf()

fishnet <- 
  fishnet[chicagoBoundary,] %>%
  mutate(uniqueID = rownames(.)) %>%
  dplyr::select(uniqueID)

#import crime data
assault <- 
  read.socrata("https://data.cityofchicago.org/Public-Safety/Crimes-2017/d62x-nvdr") %>% 
  filter(Primary.Type == "ASSAULT" & 
           Description == "SIMPLE") %>%
  mutate(x = gsub("[()]", "", Location)) %>%
  separate(x,into= c("Y","X"), sep=",") %>%
  mutate(X = as.numeric(X),
         Y = as.numeric(Y)) %>% 
  na.omit %>%
  st_as_sf(coords = c("X", "Y"), crs = 4326, agr = "constant")%>%
  st_transform(102271) %>% 
  distinct()

#joining assaults to fishnet
crime_net <- 
  assault %>% 
  dplyr::select() %>% 
  mutate(countAssault = 1) %>% 
  aggregate(., fishnet, sum) %>%
  mutate(countAssault = ifelse(is.na(countAssault), 0, countAssault),
         uniqueID = rownames(.),
         cvID = sample(round(nrow(fishnet) / 24), size=nrow(fishnet), replace = TRUE))

#data wrangling
abandonCars <- 
  read.socrata("https://data.cityofchicago.org/Service-Requests/311-Service-Requests-Abandoned-Vehicles/3c9v-pnva") %>%
  mutate(year = substr(creation_date,1,4)) %>%
  filter(year == "2017") %>%
  dplyr::select(Y = latitude, X = longitude) %>%
  na.omit() %>%
  st_as_sf(coords = c("X", "Y"), crs = 4326, agr = "constant") %>%
  st_transform(st_crs(fishnet)) %>%
  mutate(Legend = "Abandoned_Cars")

abandonBuildings <- 
  read.socrata("https://data.cityofchicago.org/Service-Requests/311-Service-Requests-Vacant-and-Abandoned-Building/7nii-7srd") %>%
  mutate(year = substr(date_service_request_was_received,1,4)) %>%
  filter(year == "2017") %>%
  dplyr::select(Y = latitude, X = longitude) %>%
  na.omit() %>%
  st_as_sf(coords = c("X", "Y"), crs = 4326, agr = "constant") %>%
  st_transform(st_crs(fishnet)) %>%
  mutate(Legend = "Abandoned_Buildings")

graffiti <- 
  read.socrata("https://data.cityofchicago.org/Service-Requests/311-Service-Requests-Graffiti-Removal-Historical/hec5-y4x5") %>%
  mutate(year = substr(creation_date,1,4)) %>%
  filter(year == "2017") %>%
  filter(where_is_the_graffiti_located_ == "Front" |
           where_is_the_graffiti_located_ == "Rear" | where_is_the_graffiti_located_ == "Side") %>%
  dplyr::select(Y = latitude, X = longitude) %>%
  na.omit() %>%
  st_as_sf(coords = c("X", "Y"), crs = 4326, agr = "constant") %>%
  st_transform(st_crs(fishnet)) %>%
  mutate(Legend = "Graffiti")

streetLightsOut <- 
  read.socrata("https://data.cityofchicago.org/Service-Requests/311-Service-Requests-Street-Lights-All-Out/zuxi-7xem") %>%
  mutate(year = substr(creation_date,1,4)) %>%
  filter(year == "2017") %>%
  dplyr::select(Y = latitude, X = longitude) %>%
  na.omit() %>%
  st_as_sf(coords = c("X", "Y"), crs = 4326, agr = "constant") %>%
  st_transform(st_crs(fishnet)) %>%
  mutate(Legend = "Street_Lights_Out")

alleyLightsOut <-
  streetLightsOut <- 
  read.socrata("https://data.cityofchicago.org/Service-Requests/311-Service-Requests-Alley-Lights-Out-Historical/t28b-ys7j") %>%
  mutate(year = substr(creation_date,1,4)) %>%
  filter(year == "2017") %>%
  dplyr::select(Y = latitude, X = longitude) %>%
  na.omit() %>%
  st_as_sf(coords = c("X", "Y"), crs = 4326, agr = "constant") %>%
  st_transform(st_crs(fishnet)) %>%
  mutate(Legend = "Alley_Lights_Out")

sanitation <-
  read.socrata("https://data.cityofchicago.org/Service-Requests/311-Service-Requests-Sanitation-Code-Complaints-Hi/me59-5fac") %>%
  mutate(year = substr(creation_date,1,4)) %>%
  filter(year == "2017") %>%
  dplyr::select(Y = latitude, X = longitude) %>%
  na.omit() %>%
  st_as_sf(coords = c("X", "Y"), crs = 4326, agr = "constant") %>%
  st_transform(st_crs(fishnet)) %>%
  mutate(Legend = "Sanitation")

liquorRetail <- 
  read.socrata("https://data.cityofchicago.org/Community-Economic-Development/Business-Licenses-Cur   rent-Liquor-and-Public-Places/nrmj-3kcf") %>%
  filter(BUSINESS.ACTIVITY == "Retail Sales of Packaged Liquor") %>%
  dplyr::select(Y = LATITUDE, X = LONGITUDE) %>%
  na.omit() %>%
  st_as_sf(coords = c("X", "Y"), crs = 4326, agr = "constant") %>%
  st_transform(st_crs(fishnet)) %>%
  mutate(Legend = "Liquor_Retail")

LowTrafficCounts <- 
  read.socrata("https://data.cityofchicago.org/Transportation/Average-Daily-Traffic-Counts/pfsx-4n4m") %>%
  filter(total_passing_vehicle_volume < 10000) %>%
  dplyr::select(Y = latitude, X = longitude) %>%
  na.omit() %>%
  st_as_sf(coords = c("X", "Y"), crs = 4326, agr = "constant") %>%
  st_transform(st_crs(fishnet)) %>%
  mutate(Legend = "Traffic_Counts")

neighborhoods <- 
  st_read("https://raw.githubusercontent.com/blackmad/neighborhoods/master/chicago.geojson") %>%
  st_transform(st_crs(fishnet)) 

#data wrangling
vars_net <- 
  rbind(abandonCars,streetLightsOut,alleyLightsOut, abandonBuildings,
        liquorRetail, graffiti, sanitation, LowTrafficCounts) %>%
  st_join(., fishnet, join=st_within) %>%
  st_set_geometry(NULL) %>%
  group_by(uniqueID, Legend) %>%
  summarize(count = n()) %>%
  full_join(fishnet) %>%
  spread(Legend, count, fill=0) %>%
  st_sf() %>%
  dplyr::select(-`<NA>`) %>%
  na.omit()


#nearest neighbor features
nn_function <- function(measureFrom,measureTo,k) {
  measureFrom_Matrix <-
    as.matrix(measureFrom)
  measureTo_Matrix <-
    as.matrix(measureTo)
  nn <-   
    get.knnx(measureTo, measureFrom, k)$nn.dist
  output <-
    as.data.frame(nn) %>%
    rownames_to_column(var = "thisPoint") %>%
    gather(points, point_distance, V1:ncol(.)) %>%
    arrange(as.numeric(thisPoint)) %>%
    group_by(thisPoint) %>%
    summarize(pointDistance = mean(point_distance)) %>%
    arrange(as.numeric(thisPoint)) %>% 
    dplyr::select(-thisPoint) %>%
    pull()
  
  return(output)  
}

#k-folds
vars_net$Abandoned_Buildings.nn =
  nn_function(st_coordinates(st_centroid(vars_net)), st_coordinates(abandonBuildings), 3)

vars_net$Abandoned_Cars.nn =
  nn_function(st_coordinates(st_centroid(vars_net)), st_coordinates(abandonCars), 3)

vars_net$Graffiti.nn =
  nn_function(st_coordinates(st_centroid(vars_net)), st_coordinates(graffiti), 3)

vars_net$Liquor_Retail.nn =
  nn_function(st_coordinates(st_centroid(vars_net)), st_coordinates(liquorRetail), 3)

vars_net$Street_Lights_Out.nn =
  nn_function(st_coordinates(st_centroid(vars_net)), st_coordinates(streetLightsOut), 3)

vars_net$Alley_Lights_Out.nn =
  nn_function(st_coordinates(st_centroid(vars_net)), st_coordinates(alleyLightsOut), 3)

vars_net$Sanitation.nn =
  nn_function(st_coordinates(st_centroid(vars_net)), st_coordinates(sanitation), 3)

vars_net$Low_Traffic_Counts.nn =
  nn_function(st_coordinates(st_centroid(vars_net)), st_coordinates(LowTrafficCounts), 3)

#nearest neighbor points plotted
vars_net.long.nn <- 
  vars_net %>%
  dplyr::select(ends_with(".nn")) %>%
  gather(Variable, value, -geometry, -uniqueID)

vars <- unique(vars_net.long.nn$Variable)
mapList <- list()

for(i in vars){
  mapList[[i]] <- 
    ggplot() +
    geom_sf(data = filter(vars_net.long.nn, Variable == i), aes(fill=value), colour=NA) +
    scale_fill_viridis(name="") +
    labs(title=i) +
    mapTheme()}

do.call(grid.arrange,c(mapList, ncol =2, top = "Nearest Neighbor risk Factors by Fishnet"))

#measure distance to one point
loopPoint <-
  neighborhoods %>%
  filter(name == "Loop") %>%
  st_centroid()

vars_net$loopDistance =
  st_distance(st_centroid(vars_net),loopPoint) %>%
  as.numeric() 

final_net <-
  left_join(crime_net, st_set_geometry(vars_net, NULL), by="uniqueID") 

#join neighborhood and police district
final_net <-
  st_centroid(final_net) %>%
  st_join(., dplyr::select(neighborhoods, name)) %>%
  st_join(., dplyr::select(policeDistricts, District)) %>%
  st_set_geometry(NULL) %>%
  left_join(dplyr::select(final_net, geometry, uniqueID)) %>%
  st_sf() %>%
  na.omit()

dplyr::select(final_net, name, District) %>%
  gather(Variable, Value, -geometry) %>%
  ggplot() +
  geom_sf(aes(fill = Value)) +
  facet_wrap(~Variable) +
  scale_fill_viridis(discrete = TRUE) +
  labs(title = "Aggregate Areas") +
  mapTheme() + theme(legend.position = "none")

#queen neighbors and visualization
final_net.nb <- poly2nb(final_net, queen=TRUE)
final_net.weights <- nb2listw(final_net.nb, style="W", zero.policy=TRUE)

#local Moran's I statistics
final_net.localMorans <- 
  cbind(
    as.data.frame(localmoran(final_net$countAssault, final_net.weights)),
    as.data.frame(final_net, NULL)) %>% 
  st_sf() %>%
  dplyr::select(Assault_Count = countAssault, 
                Local_Morans_I = Ii, 
                P_Value = `Pr(z > 0)`) %>%
  mutate(Significant_Hotspots = ifelse(P_Value <= 0.05, 1, 0)) %>%
  gather(Variable, Value, -geometry)

vars <- unique(final_net.localMorans$Variable)
varList <- list()

#calculation of local moran's i
final_net <-
  final_net %>% 
  mutate(Assault.isSig = ifelse(localmoran(final_net$countAssault, 
                                            final_net.weights)[,5] <= 0.0000001, 1, 0)) %>%
  mutate(Assault.isSig.dist = nn_function(st_coordinates(st_centroid(final_net)),
                                           st_coordinates(st_centroid(
                                             filter(final_net, Assault.isSig == 1))), 1 ))

#correlation tests
correlation.long <-
  st_set_geometry(final_net, NULL) %>%
  dplyr::select(-uniqueID, -cvID, -loopDistance, -name, -District) %>%
  gather(Variable, Value, -countAssault)

correlation.cor <-
  correlation.long %>%
  group_by(Variable) %>%
  summarize(correlation = cor(Value, countAssault, use = "complete.obs"))

#two different specifications (with and without spatial structure features)
reg.vars <- c("Abandoned_Buildings.nn", "Abandoned_Cars.nn", "Graffiti.nn", 
              "Liquor_Retail.nn", "Street_Lights_Out.nn", "Alley_Lights_Out.nn", "Sanitation.nn", 
              "Low_Traffic_Counts.nn", "loopDistance")

reg.ss.vars <- c("Abandoned_Buildings.nn", "Abandoned_Cars.nn", "Graffiti.nn", "Liquor_Retail.nn", 
                 "Street_Lights_Out.nn", "Alley_Lights_Out.nn", "Sanitation.nn", "Low_Traffic_Counts.nn", 
                 "loopDistance", "Assault.isSig", "Assault.isSig.dist")

#cross validation
crossValidate <- function(dataset, id, dependentVariable, indVariables) {
  
  allPredictions <- data.frame()
  cvID_list <- unique(dataset[[id]])
  
  for (i in cvID_list) {
    
    thisFold <- i
    cat("This hold out fold is", thisFold, "\n")
    
    fold.train <- filter(dataset, dataset[[id]] != thisFold) %>% as.data.frame() %>% 
      dplyr::select(id, geometry, indVariables, dependentVariable)
    fold.test  <- filter(dataset, dataset[[id]] == thisFold) %>% as.data.frame() %>% 
      dplyr::select(id, geometry, indVariables, dependentVariable)
    
    regression <-
      glm(countAssault ~ ., family = "poisson", 
          data = fold.train %>% 
            dplyr::select(-geometry, -id))
    
    thisPrediction <- 
      mutate(fold.test, Prediction = predict(regression, fold.test, type = "response"))
    
    allPredictions <-
      rbind(allPredictions, thisPrediction)
    
  }
  return(st_sf(allPredictions))
}

#four different regressions
reg.cv <- crossValidate(
  dataset = final_net,
  id = "cvID",
  dependentVariable = "countAssault",
  indVariables = reg.vars) %>%
  dplyr::select(cvID = cvID, countAssault, Prediction, geometry)

reg.ss.cv <- crossValidate(
  dataset = final_net,
  id = "cvID",
  dependentVariable = "countAssault",
  indVariables = reg.ss.vars) %>%
  dplyr::select(cvID = cvID, countAssault, Prediction, geometry)

reg.spatialCV <- crossValidate(
  dataset = final_net,
  id = "name",
  dependentVariable = "countAssault",
  indVariables = reg.vars) %>%
  dplyr::select(cvID = name, countAssault, Prediction, geometry)

reg.ss.spatialCV <- crossValidate(
  dataset = final_net,
  id = "name",
  dependentVariable = "countAssault",
  indVariables = reg.ss.vars) %>%
  dplyr::select(cvID = name, countAssault, Prediction, geometry)

#regression data frame
reg.summary <- 
  rbind(
    mutate(reg.cv,           Error = countAssault - Prediction,
                             Regression = "Random k-fold CV: Just Risk Factors"),
                             
    mutate(reg.ss.cv,        Error = countAssault - Prediction,
                             Regression = "Random k-fold CV: Spatial Structure"),
    
    mutate(reg.spatialCV,    Error = countAssault - Prediction,
                             Regression = "Spatial LOGO-CV: Just Risk Factors"),
                             
    mutate(reg.ss.spatialCV, Error = countAssault - Prediction,
                             Regression = "Spatial LOGO-CV: Spatial Structure")) %>%
    st_sf() 

tracts17 <- 
  get_acs(geography = "tract", variables = c("B01001_001E","B01001A_001E"), 
          year = 2017, state=17, county=031, geometry=T) %>%
  st_transform(102271)  %>% 
  dplyr::select(variable, estimate, GEOID) %>%
  spread(variable, estimate) %>%
  rename(TotalPop = B01001_001,
         NumberWhites = B01001A_001) %>%
  mutate(percentWhite = NumberWhites / TotalPop,
         raceContext = ifelse(percentWhite > .5, "Majority_White", "Majority_Non_White")) %>%
  .[neighborhoods,]

final_reg <- 
  filter(reg.summary, Regression == "Spatial LOGO-CV: Spatial Structure" |
           Regression == "Spatial LOGO-CV: Just Risk Factors") %>%
  mutate(uniqueID = rownames(.))

final_reg.tracts <- 
  st_join(st_centroid(final_reg), tracts17) %>%
  st_set_geometry(NULL) %>%
  left_join(dplyr::select(final_reg, uniqueID)) %>%
  st_sf() %>%
  na.omit()

# Compute kernel density
assault_ppp <- as.ppp(st_coordinates(assault), W = st_bbox(final_net))
assault_KD <- spatstat::density.ppp(assault_ppp, 1000)

# Convert kernel density to grid cells taking the mean
assault_KDE_sf <- as.data.frame(assault_KD) %>%
  st_as_sf(coords = c("x", "y"), crs = st_crs(final_net)) %>%
  aggregate(., final_net, mean) %>%
  mutate(label = "Kernel Density",
         Risk_Category = ntile(value, 100),
         Risk_Category = case_when(
           Risk_Category >= 90 ~ "90% to 100%",
           Risk_Category >= 70 & Risk_Category <= 89 ~ "70% to 89%",
           Risk_Category >= 50 & Risk_Category <= 69 ~ "50% to 69%",
           Risk_Category >= 30 & Risk_Category <= 49 ~ "30% to 49%",
           Risk_Category >= 1 & Risk_Category <= 29 ~ "1% to 29%")) %>%
  bind_cols(
    aggregate(
      dplyr::select(assault) %>% mutate(AssaultCount = 1), ., length) %>%
      mutate(AssaultCount = replace_na(AssaultCount, 0))) %>%
  dplyr::select(label, Risk_Category, AssaultCount)

head(assault_KDE_sf)

#repeat process above for risk predictions
assault_risk_sf <-
  filter(final_reg, Regression == "Spatial LOGO-CV: Spatial Structure") %>%
  mutate(label = "Risk Predictions",
         Risk_Category = ntile(Prediction, 100),
         Risk_Category = case_when(
           Risk_Category >= 90 ~ "90% to 100%",
           Risk_Category >= 70 & Risk_Category <= 89 ~ "70% to 89%",
           Risk_Category >= 50 & Risk_Category <= 69 ~ "50% to 69%",
           Risk_Category >= 30 & Risk_Category <= 49 ~ "30% to 49%",
           Risk_Category >= 1 & Risk_Category <= 29 ~ "1% to 29%")) %>%
  bind_cols(
    aggregate(
      dplyr::select(assault) %>% mutate(AssaultCount = 1), ., length) %>%
      mutate(AssaultCount = replace_na(AssaultCount, 0))) %>%
  dplyr::select(label,Risk_Category, AssaultCount)

```

## Introduction
Spatial risk models have become more utilized in the public sector to improve current business practices for predicting outcomes. In the realm of Public Safety, the predicted occurrence of aggravated assault crimes is generally based on 'keneral density' modeling, where crimes are predicted to be located in areas with a high density of recorded aggravated assault crimes. The spatial risk model developed below utilizes aggravated assault crimes from Chicago's Open Data portal, along with eight risk factors also derived from the Open Data Portal. The goal of this markdown is to analyze the accuracy and generalizability of the model, while also determining if the model includes racial fairness. 

## Mapping Aggravated Assault in Chicago

The map below shows the location of reported cases of assault in Chicago from 2017. In this model, it is likely that a reporting bias may exist in low-income, non-white areas where there is a higher level of mistrust of public safety officers. Therefore, it is more likely that cases of assault where reported in middle and higher income neighborhoods where residents are majority white. 
```{r}
ggplot() + 
  geom_sf(data = chicagoBoundary) +
  geom_sf(data = assault, colour="red", size=0.1, show.legend = "point") +
  labs(title= "Aggravated Assault, Chicago - 2017") +
  mapTheme()
```


To begin developing a prediction model, assault features are mapped with a fishnet to create a count of aggravated assault by fishnet.
```{r}
crime_net <- 
  assault %>% 
  dplyr::select() %>% 
  mutate(countAssault = 1) %>% 
  aggregate(., fishnet, sum) %>%
  mutate(countAssault = ifelse(is.na(countAssault), 0, countAssault),
         uniqueID = rownames(.),
         cvID = sample(round(nrow(fishnet) / 24), size=nrow(fishnet), replace = TRUE))

#map results
ggplot() +
  geom_sf(data = crime_net, aes(fill = countAssault)) +
  scale_fill_viridis() +
  labs(title = "Count of Assault for the fishnet") +
  mapTheme()
```

## Incorporating Risk Factors (Feature Engineering)

A series of eight risk factors were wrangled to determine if assault is more prevalent when exposed to these characteristics. The risk factors are mapped below.
```{r}
#data wrangling
vars_net <- 
  rbind(abandonCars,streetLightsOut,alleyLightsOut, abandonBuildings,
        liquorRetail, graffiti, sanitation, LowTrafficCounts) %>%
  st_join(., fishnet, join=st_within) %>%
  st_set_geometry(NULL) %>%
  group_by(uniqueID, Legend) %>%
  summarize(count = n()) %>%
  full_join(fishnet) %>%
  spread(Legend, count, fill=0) %>%
  st_sf() %>%
  dplyr::select(-`<NA>`) %>%
  na.omit()

#map features
vars_net.long <- 
  vars_net %>%
  gather(Variable, value, -geometry, -uniqueID)

vars <- unique(vars_net.long$Variable)
mapList <- list()

for(i in vars){
  mapList[[i]] <- 
    ggplot() +
    geom_sf(data = filter(vars_net.long, Variable == i), aes(fill=value), colour=NA) +
    scale_fill_viridis(name="") +
    labs(title=i) +
    mapTheme()}

do.call(grid.arrange,c(mapList, ncol =2, top = "Risk Factors by Fishnet"))
```


## Local Moranâ€™s I

To better understand the spatial structure of aggravated assault, a Local Moran's I was utilized to visualize and test the correlation of `countAssault`. 
```{r}
final_net.localMorans <- 
  cbind(
    as.data.frame(localmoran(final_net$countAssault, final_net.weights)),
    as.data.frame(final_net, NULL)) %>% 
  st_sf() %>%
  dplyr::select(Assault_Count = countAssault, 
                Local_Morans_I = Ii, 
                P_Value = `Pr(z > 0)`) %>%
  mutate(Significant_Hotspots = ifelse(P_Value <= 0.05, 1, 0)) %>%
  gather(Variable, Value, -geometry)

vars <- unique(final_net.localMorans$Variable)
varList <- list()

for(i in vars){
  varList[[i]] <- 
    ggplot() +
    geom_sf(data = filter(final_net.localMorans, Variable == i), aes(fill = Value), colour=NA) +
    scale_fill_viridis(name="") +
    labs(title=i) +
    mapTheme()}

do.call(grid.arrange,c(varList, ncol = 4, top = "Local Morans I statistics, Aggravated Assault"))
```


## Testing the Correlation of Features to Assault

The charts below examine the correlation between each risk factor and the outcome, assault. Significant risk factors include abandoned buildings, alley light outages, and abandoned cars. In each of these factors, an increase in the risk factor results in an increase in assault and the futher the distance from these risk factors, the less occurrences of assault.
```{r correlation plot, fig.height=15, fig.width=7.5}
ggplot(correlation.long, aes(Value, countAssault)) +
  geom_point(size = 0.1) +
  geom_text(data = correlation.cor, aes(label = paste("r =", round(correlation, 2))),
            x=-Inf, y=Inf, vjust = 1, hjust = -.1) +
  geom_smooth(method = "lm", se = FALSE, colour = "#a2d7d8") +
  facet_wrap(~Variable, ncol = 2, scales = "free") +
  labs(title = "Assault count as a function of risk factors")
```


## Poisson Regression Model and Results

The bar chart below shows the distribution of assault by grid cell. Based on this distribution, it is clear that the Poisson Regression model is best suited for this case. 
```{r}
ggplot(final_net, aes(countAssault)) + 
  geom_histogram(binwidth = 1) +
  labs(title = "Distribution of assault by grid cell")
```


The set of maps below shows mapped prediction errors by random k-fold and spatial cross validation. When comparing the two validation models, the lack of the spatial components seems to be resulting in increased errors. 
```{r}
filter(reg.summary, Regression == "Spatial LOGO-CV: Just Risk Factors" | 
         Regression == "Spatial LOGO-CV: Spatial Structure") %>%
  ggplot() +
  geom_sf(aes(fill = Error)) +
  facet_wrap(~Regression) +
  scale_fill_viridis() +
  labs(title = "Assault errors by Regression") +
  mapTheme()
```

The Mean Absolute Error (MAE) for both cross-validation models is provided in the table below. The most significant takeaway from this table is the noticable difference in the absolute error -- incorporating spatial structure reduces the MAE.
```{r}
st_set_geometry(reg.summary, NULL) %>%
  group_by(Regression) %>% 
  summarize(MAE = round(mean(abs(Prediction - countAssault), na.rm = T),2),
            SD_MAE = round(sd(abs(Prediction - countAssault), na.rm = T),2)) %>% 
  kable(caption = "MAE by regression") %>%
  kable_styling("striped", full_width = F) %>%
  row_spec(2, color = "black", background = "#FDE725FF") %>%
  row_spec(4, color = "black", background = "#FDE725FF") 
```


## Neighborhood Context

When incorporating race data by Census Tract, the table below shoes that both models are over-predicting in majority non-white neighborhoods and underpredicting in majority white neighborhoods. It should also be noted that a much smaller gap exists between the two categories in the spatial structure model. 
```{r}
st_set_geometry(final_reg.tracts, NULL) %>%
  group_by(Regression, raceContext) %>%
  summarize(mean.Error = mean(Error, na.rm = T)) %>%
  spread(raceContext, mean.Error) %>%
  kable(caption = "Mean Error by neighborhood racial context") %>%
  kable_styling("striped", full_width = F) 
```

## Spatial Risk Model vs. Current Business Practices
In a well-fitted model, the areas of high risk will be targeted to places with a high density of points. In the risk predictions map below, this seems to be the case. Compared to the kernal density model primarily used in business practices, the spatial risk predictions are better targeted.
```{r}
rbind(assault_KDE_sf, assault_risk_sf) %>%
  gather(Variable, Value, -label, -Risk_Category, -geometry) %>%
  ggplot() +
  geom_sf(aes(fill = Risk_Category), colour = NA) +
  geom_sf(data = sample_n(assault, 1500), size = .1, colour = "black") +
  facet_wrap(~label, ) +
  scale_fill_viridis(discrete = TRUE) +
  labs(title="Comparison of Kernel Density and Risk Predictions",
       subtitle="Relative to test set points (in black)") +
  mapTheme()
```

To further compare the two models, the rate of assault points by risk category is calculated and displayed in the chart below. The risk predictions in the highest risk cateogry should be greater than that of the kernal density model. In this spatial risk model, such is the case. 
```{r}
rbind(assault_KDE_sf, assault_risk_sf) %>%
  st_set_geometry(NULL) %>%
  gather(Variable, Value, -label, -Risk_Category) %>%
  group_by(label, Risk_Category) %>%
  summarize(countAssault = sum(Value)) %>%
  ungroup() %>%
  group_by(label) %>%
  mutate(Rate_of_test_set_crimes = countAssault / sum(countAssault)) %>%
  ggplot(aes(Risk_Category,Rate_of_test_set_crimes)) +
  geom_bar(aes(fill=label), position="dodge", stat="identity") +
  scale_fill_viridis(discrete = TRUE)
```

## Conclusion
The goal of this spatial risk model was to predict aggravated assault in Chicago in a way that is both accurate and generalizable. When developing the model, the primary concern was that reporting bias would skew the results and only show results in areas where people have a higher propensity to report crime. While selection bias may be difficult to avoid with the data utilized, this model is more precise in locating predicted aggravated assault than current business practices.  

In terms of generalizability, the model is able to generalize relatively well across neighborhoods. When race data is incorporated into the results, the spatial risk model is significantly fairer than a model developed without a spatial component. This report concludes that this spatial risk model is recommended to be put into production. 